# Анализ и определение корреляций между параметрами некоторой радиотехнической структуры по набору данных.

## [Основной анализ (Jupyter Notebook)](new_metod.ipynb)

## [Дополнительная расширенная информация по данному направлению](docs/article.md)

В данной работе мы рассмотрим другой способ анализа оптимизации параметров. Проанализируем накопленные знания, результаты вычислений рабочих областей традиционными интерпретируемыми алгоритмами. Попробуем определить скрытые взаимосвязи и корреляцию  параметров. Для этого спроектируем нейронную модель и обучим её на данных.

В результате выполнения кинематики был создан набор данных, содержащий значения параметров робота и  соответствующих значений обобщенных координат. Полученные данные разделены на тренировочный набор и проверочный набор в соотношении 80% тренировочный набор и 20% проверочный.

На основе кинематического анализа были сгенерированы данные о рабочем пространстве. В научной литературе предлагается несколько методов оценки рабочего пространства. Во-первых, для оценки рабочего пространства используется трехмерное пространство (параллелепипеды).

Процесс определения параметров нейронной сети является сложной и важной задачей, как правило нет какого то обязательного правила составления нейронных сетей, зачастую параметры нейронных сейте подбираются эмпирические в процессе тестирования или основываясь на личностном опыте.

В качестве библиотеки проектирования нейронных сетей используем распространённую библиотеку Pytorch. Выходные параметры модели:
- `input_size`: Размер входного слоя, который должен соответствовать количеству признаков в ваших данных.
- `output_size`: Размер выходного слоя, который определяет количество целевых переменных, которые модель будет предсказывать. Для одномерной регрессии это будет 1.
- `layer_sizes`: Список, определяющий размеры скрытых слоёв. Каждый элемент списка указывает на количество нейронов в соответствующем слое. По умолчанию зададим один скрытый слой размером 64 нейрона.
- `activation_fn`: Функция активации, применяемая к выходам каждого скрытого слоя. По умолчанию используем функцию активации ReLU.

```python
import torch.nn as nn
import torch.nn.functional as F

class RegressionModel(nn.Module):
    def __init__(self, 
                 input_size, 
                 output_size,
                 layer_sizes=[64], 
                 activation_fn=F.relu):
        super(RegressionModel, self).__init__()
        self.input_size = input_size
        self.output_size = output_size
        self.layer_sizes = layer_sizes
        self.activation_fn = activation_fn        
        self.layers = nn.ModuleList()        
        prev_size = input_size
        for size in layer_sizes:
            self.layers.append(nn.Linear(prev_size, size))
            prev_size = size        
        self.layers.append(nn.Linear(prev_size, output_size))
        self.activation_fn = activation_fn

    def forward(self, x):
        for layer in self.layers[:-1]:
            x = self.activation_fn(layer(x))
        x = self.layers[-1](x)
        return x

```

Принцип работы:
1. Входной вектор данных `x` последовательно проходит через все слои модели.
2. На выходе каждого скрытого слоя применяется функция активации (по умолчанию `F.relu`), что позволяет модели изучать нелинейные зависимости между входными и выходными данными.
3. Последний слой (выходной слой) возвращает линейный выход, который может интерпретироваться как прогнозируемое значение целевой переменной для задачи регрессии.

Основной метод:
- `forward(x)`: Определяет прямой проход (forward pass) через модель. Для каждого слоя, кроме последнего, применяется функция активации к его выходу. Выход последнего слоя возвращается напрямую, что характерно для задач регрессии, где мы хотим получить непрерывное значение без применения функции активации.
  
Эта модель представляет собой гибкий инструмент для построения нейронных сетей различной архитектуры для решения регрессионных задач, позволяя экспериментировать с различным количеством слоёв и функциями активации.

Функция ReLU (Rectified Linear Unit) — это функция активации, широко используемая в нейронных сетях, особенно в глубоком обучении. Функция ReLU и её производные помогают решать проблемы, связанные с градиентным спуском, такие как затухание или взрыв градиента, ускоряя процесс обучения моделей глубокого обучения.

Функция ReLU определяется следующим образом для входа $x$:

$$ \text{ReLU}(x) = \max(0, x) $$

Это означает, что если вход $x$ положителен, функция возвращает $x$, а если $x$ отрицательный — возвращает 0.

График функции ReLU прост: для отрицательных значений $x$ функция принимает значение 0, а для положительных значений $x$ функция линейно возрастает с угловым коэффициентом 1.

Производная функции ReLU используется в процессе обратного распространения ошибки (backpropagation) для обновления весов нейронной сети. Она определяется следующим образом:

$$ \text{ReLU}'(x) = 
   \begin{cases} 
   0 & \text{if } x \leq 0 \\
   1 & \text{if } x > 0 
   \end{cases}
$$

Преимущества:
- **Простота вычисления**: Поскольку ReLU является кусочно-линейной функцией, она требует меньше вычислительных ресурсов по сравнению с другими функциями активации, такими как сигмоид или гиперболический тангенс.
- **Решение проблемы затухания градиента**: В отличие от сигмоидальных функций, градиент ReLU не затухает для большого диапазона положительных значений, что облегчает обучение глубоких нейронных сетей.
- **Способствует разреженности активаций**: Поскольку ReLU возвращает 0 для всех отрицательных значений входа, это приводит к тому, что в любой момент активны только часть нейронов. Это повышает эффективность и облегчает получение разреженных представлений данных.

Недостатки:
- **Проблема "затухания"**: Если нейрон начинает выдавать отрицательные значения для всех входов в датасете, он может "затухнуть", то есть перестать вносить какой-либо вклад в адаптацию сети, поскольку его градиент будет нулевым. Решениями этой проблемы являются варианты ReLU, такие как Leaky ReLU или Parametric ReLU, которые позволяют передавать небольшой градиент, даже когда вход отрицателен.

В целях  обеспечения масштабируемости и гибкости регулирования модели обучения используем методы декомпозиции процесса обучения (помести процесс обучения в отдельный класс Trainer, это общепринятая практика). Этот класс инкапсулирует логику обучения, включая итерации по эпохам, обработку пакетов данных, вычисление функции потерь, выполнение шагов оптимизации, а также валидацию модели.

Основные входные параметры:
- **model**: Экземпляр модели, которую нужно обучить.
- **criterion**: Функция потерь, используемая для оценки ошибки модели. По умолчанию зададим `MSELoss` [35], подходящий для задач регрессии.
- **optimizer**: Оптимизатор для обновления весов модели на основе градиентов. По умолчанию задаётся оптимизатор Adam с скоростью обучения 0.001.
- **device**: Устройство, на котором будут выполняться вычисления (`cpu` или `cuda`).

Методы класса:
- **_train**: Приватный метод для выполнения одной эпохи обучения модели на тренировочных данных.
- **_eval**: Приватный метод для оценки модели на валидационных данных.
- **fit**: Публичный метод для запуска процесса обучения, который последовательно вызывает `_train` и `_eval` для каждой эпохи.
- **plot_metrics**: Визуализирует графики потерь и MAE для тренировочных и валидационных данных по эпохам.
- **predict**: Предсказывает выходные данные для входных данных после обучения модели.
- **save_model**: Сохраняет состояние модели и конфигурацию тренера в файл.
- **load_model**: Загружает модель и конфигурацию тренера из файла.

Особенности:
- Этот класс обеспечивает удобную обёртку для стандартного цикла обучения модели с возможностью валидации.
- Использование DataLoader в методах `_train` и `_eval` позволяет эффективно обрабатывать данные пакетами, что важно для обучения на больших наборах данных.
- Поддержка гибкой конфигурации оптимизатора и функции потерь делает класс универсальным для различных задач машинного обучения.
- Встроенная поддержка визуализации процесса обучения с помощью `plot_metrics` позволяет наглядно отслеживать прогресс.

В целом, класс `Trainer` представляет собой мощный инструмент для разработки и тестирования моделей машинного обучения, облегчая процесс обучения за счёт автоматизации рутинных задач.

В качестве оптимизатора был выбран Adam (Adaptive Moment Estimation) — это метод стохастической оптимизации, который применяется для обновления весов нейронной сети в процессе обучения. Он сочетает в себе идеи двух других методов оптимизации: RMSprop и стохастического градиентного спуска с моментом. Adam адаптирует скорость обучения для каждого параметра индивидуально, используя оценки первого и второго моментов градиентов.

Пусть $g_t$ обозначает градиент в момент времени $t$, $m_t$ и $v_t$ — оценки первого и второго моментов градиентов соответственно. Тогда шаги алгоритма Adam можно описать следующими формулами:

1. **Вычисление градиентов для каждого параметра:**
   $$g_t = \nabla_{\theta}f_t(\theta_{t-1})$$

2. **Обновление оценок первого момента (аналогично моменту в стохастическом градиентном спуске):**
   $$m_t = \beta_1 \cdot m_{t-1} + (1 - \beta_1) \cdot g_t$$

3. **Обновление оценок второго момента (аналогично RMSprop):**
   $$v_t = \beta_2 \cdot v_{t-1} + (1 - \beta_2) \cdot g_t^2$$

4. **Коррекция оценок моментов для учета их инициализации в нуле:**
   $$ \hat{m}_t = \frac{m_t}{1 - \beta_1^t} $$
   $$ \hat{v}_t = \frac{v_t}{1 - \beta_2^t} $$

5. **Обновление параметров:**
   $$ \theta_t = \theta_{t-1} - \frac{\alpha \cdot \hat{m}_t}{\sqrt{\hat{v}_t} + \epsilon} $$

где:
- $\theta_t$ — параметры модели на шаге $t$,
- $\alpha$ — скорость обучения,
- $\beta_1$ и $\beta_2$ — коэффициенты экспоненциального затухания для оценок моментов (обычно выбираются близко к 1),
- $\epsilon$ — малое положительное число, добавляемое для устойчивости деления (чтобы избежать деления на ноль).

Adam популярен благодаря своей эффективности в широком диапазоне задач машинного обучения и его способности адаптироваться к различным условиям задачи

На этом этапе еще одним важным аспектом является критерий сходимости. Это может быть максимальное количество оценок функции, конкретное минимальное значение средней квадратичной ошибки (`MSE`) или подтверждение эффективности работы обученной сети на основе данных, зарезервированных для валидации. Этот критерий накладывается пользователем, определяющим сеть, но может зависеть от области применения, для которой используется нейронная сеть. В данной ситуации в качестве критерия принята функция `MSE`.

Функция потерь среднеквадратичной ошибки (MSE, Mean Squared Error Loss) — это стандартная мера, используемая для оценки разности между предсказанными значениями модели и фактическими значениями. Она часто применяется в задачах регрессии для оптимизации параметров модели. Формула MSE вычисляется как среднее квадратов разностей между целевыми значениями и значениями, предсказанными моделью.

Если обозначить целевые значения как $y_i$ и соответствующие им предсказанные значения как $\hat{y}_i$ для $i$-го примера в наборе данных, то MSE вычисляется по формуле:

$$ \text{MSE} = \frac{1}{n} \sum_{i=1}^{n} (\hat{y}_i - y_i)^2 $$

где:
- $n$ — количество примеров в наборе данных,
- $y_i$ — фактическое значение цели для $i$-го примера,
- $\hat{y}_i$ — предсказанное значение для $i$-го примера.

Цель оптимизации с использованием функции потерь MSE — минимизировать среднеквадратичное отклонение между предсказанными и реальными значениями, тем самым улучшая точность модели. В контексте обучения нейронной сети, это означает адаптацию весов сети таким образом, чтобы минимизировать значение `MSE` через процесс обратного распространения ошибки и градиентного спуска.

Последнее что хочется отметить, что для данные предварительно нормализованы, для этого использован удобный инструмент библиотеки `Scikit Learn` - `StandardScaler`.

Это метод предварительной обработки данных, который часто используется для нормализации характеристик (признаков) в машинном обучении перед обучением модели. Он преобразует данные так, чтобы их распределение имело среднее значение, равное 0, и стандартное отклонение, равное 1. Этот процесс известен также как стандартизация или z-оценка.

Стандартизация данных помогает улучшить процесс обучения, делая его более стабильным и ускоряя сходимость в алгоритмах, чувствительных к масштабу признаков, таких как линейная регрессия, логистическая регрессия, и методы, использующие градиентный спуск.

Допустим, у нас есть набор данных $X$, состоящий из $n$ признаков (характеристик), и мы хотим стандартизировать один из признаков. Пусть $x$ будет вектором значений этого признака для всех примеров в наборе данных. Тогда процесс стандартизации можно описать следующими шагами:

1. **Вычисление среднего значения ($\mu$) для признака $x$:**
   $$ \mu = \frac{1}{n} \sum_{i=1}^{n} x_i $$
   
   где $x_i$ — значение $i$-го примера для признака $x$, а $n$ — общее количество примеров.

2. **Вычисление стандартного отклонения ($\sigma$) для признака $x$:**
   $$ \sigma = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (x_i - \mu)^2} $$
   
3. **Стандартизация значения признака для каждого примера:**
   $$ x'_i = \frac{x_i - \mu}{\sigma} $$
   
   где $x'_i$ — стандартизированное значение признака $x$ для $i$-го примера.

После применения `StandardScaler`, каждый признак в новом наборе данных будет иметь среднее значение, равное 0, и стандартное отклонение, равное 1. Это делает признаки более сопоставимыми и упрощает обучение моделей машинного обучения.

Далее идёт процесс обучения нейронной сети.

После обучения нейронных сетей, проведенного на третьем этапе, производительность сети была оценена на валидационных наборах данных (с использованием 20% доли, зарезервированной на 20% от каждого набора данных, зарезервированных на первом этапе). 

![Анализ обучения](/imgs/MAE_metrics.png)